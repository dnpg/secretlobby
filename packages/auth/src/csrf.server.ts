import { randomBytes, createHmac, timingSafeEqual } from "crypto";

/**
 * CSRF Token Configuration
 */
const CSRF_TOKEN_LENGTH = 32; // 32 bytes = 64 hex characters
const CSRF_TOKEN_SEPARATOR = ".";

/**
 * Get CSRF secret from environment
 * Falls back to SESSION_SECRET if CSRF_SECRET is not set
 */
function getCsrfSecret(): string {
  const secret = process.env.CSRF_SECRET || process.env.SESSION_SECRET;

  if (!secret || secret.length < 32) {
    throw new Error(
      "CSRF_SECRET or SESSION_SECRET must be set and at least 32 characters long"
    );
  }

  return secret;
}

/**
 * Generate a CSRF token
 * Format: {randomValue}.{hmac}
 */
export function generateCsrfToken(): string {
  const randomValue = randomBytes(CSRF_TOKEN_LENGTH).toString("hex");
  const secret = getCsrfSecret();

  // Create HMAC signature of the random value
  const hmac = createHmac("sha256", secret)
    .update(randomValue)
    .digest("hex");

  return `${randomValue}${CSRF_TOKEN_SEPARATOR}${hmac}`;
}

/**
 * Validate a CSRF token
 * Returns true if the token is valid, false otherwise
 */
export function validateCsrfToken(token: string | null | undefined): boolean {
  if (!token || typeof token !== "string") {
    return false;
  }

  const parts = token.split(CSRF_TOKEN_SEPARATOR);
  if (parts.length !== 2) {
    return false;
  }

  const [randomValue, providedHmac] = parts;

  // Validate format
  if (!randomValue || !providedHmac) {
    return false;
  }

  if (randomValue.length !== CSRF_TOKEN_LENGTH * 2) {
    return false;
  }

  try {
    const secret = getCsrfSecret();

    // Recompute HMAC
    const expectedHmac = createHmac("sha256", secret)
      .update(randomValue)
      .digest("hex");

    // Use timing-safe comparison to prevent timing attacks
    const expectedBuffer = Buffer.from(expectedHmac, "hex");
    const providedBuffer = Buffer.from(providedHmac, "hex");

    if (expectedBuffer.length !== providedBuffer.length) {
      return false;
    }

    return timingSafeEqual(expectedBuffer, providedBuffer);
  } catch (err) {
    return false;
  }
}

/**
 * Extract CSRF token from request
 * Checks in this order:
 * 1. Form data (_csrf field)
 * 2. X-CSRF-Token header
 * 3. X-XSRF-Token header (for compatibility)
 */
export async function extractCsrfToken(request: Request): Promise<string | null> {
  // Try form data first (for traditional form submissions)
  if (
    request.method === "POST" &&
    request.headers.get("content-type")?.includes("application/x-www-form-urlencoded")
  ) {
    try {
      const formData = await request.clone().formData();
      const token = formData.get("_csrf");
      if (token && typeof token === "string") {
        return token;
      }
    } catch {
      // Not form data or already consumed
    }
  }

  // Try JSON body (for API requests)
  if (
    request.method === "POST" &&
    request.headers.get("content-type")?.includes("application/json")
  ) {
    try {
      const body = await request.clone().json();
      if (body && typeof body === "object" && "_csrf" in body && typeof body._csrf === "string") {
        return body._csrf;
      }
    } catch {
      // Not JSON or already consumed
    }
  }

  // Try headers
  const headerToken =
    request.headers.get("x-csrf-token") ||
    request.headers.get("x-xsrf-token");

  if (headerToken) {
    return headerToken;
  }

  return null;
}

/**
 * Verify CSRF token from request
 * Uses HMAC validation (stateless) - no session token comparison needed
 *
 * The HMAC signature proves the token was generated by our server with our secret.
 * This is a "Signed CSRF Token" pattern and is secure because:
 * - Only our server can generate valid HMAC signatures
 * - An attacker cannot forge a valid token without the secret
 *
 * Throws a Response if verification fails
 */
export async function verifyCsrfToken(
  request: Request,
  _sessionToken?: string | undefined
): Promise<void> {
  const token = await extractCsrfToken(request);

  // Validate token format and HMAC signature
  // The HMAC validation proves the token was generated by our server
  if (!validateCsrfToken(token)) {
    throw new Response("Invalid CSRF token", {
      status: 403,
      statusText: "Forbidden",
      headers: {
        "Content-Type": "text/plain",
      },
    });
  }

  // Note: Session token comparison removed because:
  // 1. HMAC validation already proves the token came from our server
  // 2. React Router loaders return data, not Response objects, so session
  //    cookies set during getCsrfToken() are discarded
  // 3. The signed token pattern is sufficient for CSRF protection
}

/**
 * Check if request method requires CSRF protection
 */
export function requiresCsrfProtection(request: Request): boolean {
  const method = request.method.toUpperCase();
  return ["POST", "PUT", "PATCH", "DELETE"].includes(method);
}

/**
 * CSRF protection middleware for loaders and actions
 * Call this at the start of any loader/action that modifies data
 *
 * Uses HMAC-signed tokens for stateless validation - no session token needed.
 *
 * @example
 * export async function action({ request }: Route.ActionArgs) {
 *   await csrfProtect(request);
 *   // ... rest of action
 * }
 */
export async function csrfProtect(
  request: Request,
  _sessionToken?: string | undefined
): Promise<void> {
  if (requiresCsrfProtection(request)) {
    await verifyCsrfToken(request);
  }
}
